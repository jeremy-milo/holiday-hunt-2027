<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>9. cancel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="puzzle-style.css">
    
    <style>
        /* GAME BOARD STYLES */
        .game-status {
            font-size: 1.2rem;
            color: #f6d365;
            margin-bottom: 15px;
            font-weight: bold;
            min-height: 1.5em;
        }

        .grid-wrapper {
            display: grid;
            position: relative;
            grid-template-columns: repeat(10, 1fr); 
            grid-template-rows: repeat(10, 1fr);
            gap: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 450px;
            aspect-ratio: 1/1;
            margin: 0 auto 20px auto; /* Centered */
        }

        .grid-cell {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            width: 100%;
            height: 100%;
            aspect-ratio: 1/1; 
        }
        
        .grid-cell:hover { background: rgba(255, 255, 255, 0.2); }

        .cane-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: revealCane 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 0;
            transform-origin: center;
        }

        .cane-svg {
            width: 100%; height: 100%; display: block;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
        }

        .swirl {
            background: repeating-conic-gradient(from 0deg, #fff 0deg 20deg, #d32f2f 20deg 40deg);
            border-radius: 50%; width: 80%; height: 80%;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .miss {
            color: #ff4444; font-weight: bold; font-size: 1.2rem; animation: shake 0.3s;
        }
        .miss::after { content: "X"; }

        .feedback-msg {
            height: 20px; font-size: 0.9rem; color: #ff9; margin-top: 5px; font-style: italic;
        }

        /* Animations */
        @keyframes popIn { 0% { transform: scale(0); } 100% { transform: scale(1); } }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-2px); } 75% { transform: translateX(2px); } 100% { transform: translateX(0); } }
        @keyframes revealCane { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
    <svg width="0" height="0" style="position: absolute;">
      <defs>
        <pattern id="candyStripes" patternUnits="userSpaceOnUse" width="20" height="20" patternTransform="rotate(45)">
          <rect width="10" height="20" fill="#d32f2f"/>
          <rect x="10" width="10" height="20" fill="#ffffff"/>
        </pattern>
      </defs>
    </svg>

    <canvas id="snow-canvas"></canvas>
    
    <div class="container">
        <div class="puzzle-box">
            <h1>Puzzle 9: Candy Cane Quest</h1>
            <p class="instructions">The grid below is hiding three candy canes, and each one is four squares long. Tap the squares to find them all before you run out of guesses!</p>
           
            <div class="game-status" id="status-display">35 guesses remaining</div>

            <div class="grid-wrapper" id="game-grid"></div>

            <div class="feedback-msg" id="feedback"></div>

            <div id="ui-layer" class="ui-layer hidden-ui">
                <div id="win-screen">
                    <div class="game-msg">Sweet success!</div>
                    <p id="end-subtitle" style="color: #ddd; margin-bottom: 20px;"></p>
                    <button class="btn-style" id="end-btn" onclick="">Next puzzle</button>
                </div>
            </div>
        </div>

        <div class="spacer-large"></div>
        <div class="hidden-clue">9. cancel</div>
    </div>

    <script>
        /* --- GAME LOGIC --- */
        const GRID_SIZE = 10; const NUM_SHIPS = 3; const SHIP_LENGTH = 4; const MAX_GUESSES = 35;
        let grid = []; let ships = []; let guesses = []; let hits = 0; let guessesLeft = MAX_GUESSES; let gameActive = true;

        function initGame() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            ships = []; guesses = []; hits = 0; guessesLeft = MAX_GUESSES; gameActive = true;
            document.getElementById('status-display').innerText = `${guessesLeft} guesses remaining`;
            document.getElementById('feedback').innerText = "Tap a square to search!";
            const ui = document.getElementById('ui-layer');
            ui.classList.add('hidden-ui'); ui.classList.remove('active-ui');
            placeShips(); renderGrid();
        }

        function placeShips() {
            ships = []; let placed = 0;
            while (placed < NUM_SHIPS) {
                let orientation = Math.random() < 0.5 ? 'H' : 'V';
                let r, c; let valid = true; let currentCoords = [];
                if (orientation === 'H') {
                    r = Math.floor(Math.random() * GRID_SIZE); c = Math.floor(Math.random() * (GRID_SIZE - SHIP_LENGTH + 1));
                    for (let i = 0; i < SHIP_LENGTH; i++) { if (grid[r][c+i] === 1) valid = false; currentCoords.push({r: r, c: c+i}); }
                } else {
                    r = Math.floor(Math.random() * (GRID_SIZE - SHIP_LENGTH + 1)); c = Math.floor(Math.random() * GRID_SIZE);
                    for (let i = 0; i < SHIP_LENGTH; i++) { if (grid[r+i][c] === 1) valid = false; currentCoords.push({r: r+i, c: c}); }
                }
                if (valid) { currentCoords.forEach(coord => grid[coord.r][coord.c] = 1); ships.push({ coords: currentCoords, hits: 0 }); placed++; }
            }
        }

        function renderGrid() {
            const container = document.getElementById('game-grid'); container.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let cell = document.createElement('div'); cell.className = 'grid-cell'; cell.id = `cell-${r}-${c}`;
                    cell.onclick = () => handleCellClick(r, c); container.appendChild(cell);
                }
            }
        }

        function handleCellClick(r, c) {
            if (!gameActive) return;
            const feedbackEl = document.getElementById('feedback'); const statusEl = document.getElementById('status-display');
            const key = `${r},${c}`; if (guesses.includes(key)) return;
            guesses.push(key); guessesLeft--; statusEl.innerText = `${guessesLeft} guesses remaining`;
            const cell = document.getElementById(`cell-${r}-${c}`); cell.style.cursor = 'default';

            if (grid[r][c] === 1) {
                let swirl = document.createElement('div'); swirl.className = 'swirl'; cell.appendChild(swirl); hits++;
                let ship = ships.find(s => s.coords.some(coord => coord.r === r && coord.c === c));
                if (ship) {
                    ship.hits++;
                    if (ship.hits === SHIP_LENGTH) {
                        setTimeout(() => revealCandyCane(ship), 300); feedbackEl.innerText = "DELICIOUS! You found a whole Candy Cane!"; feedbackEl.style.color = "#fff"; feedbackEl.style.textShadow = "0 0 10px #f00";
                    } else { feedbackEl.innerText = "Tasty! Found a piece of candy cane."; feedbackEl.style.color = "#8f8"; feedbackEl.style.textShadow = "none"; }
                }
                checkWin();
            } else {
                cell.classList.add('miss'); feedbackEl.innerText = "Nothing here but snow."; feedbackEl.style.color = "#ff9"; feedbackEl.style.textShadow = "none"; checkLoss();
            }
        }

        function revealCandyCane(ship) {
            ship.coords.forEach(coord => { let cell = document.getElementById(`cell-${coord.r}-${coord.c}`); cell.innerHTML = ''; });
            ship.coords.sort((a, b) => a.r - b.r || a.c - b.c);
            let isHorizontal = false; if (ship.coords.length > 1 && ship.coords[0].r === ship.coords[1].r) isHorizontal = true;
            const r = ship.coords[0].r; const c = ship.coords[0].c;
            const container = document.getElementById('game-grid'); const overlay = document.createElement('div'); overlay.className = 'cane-overlay';
            if (isHorizontal) { overlay.style.gridRow = `${r + 1} / span 1`; overlay.style.gridColumn = `${c + 1} / span ${SHIP_LENGTH}`; } 
            else { overlay.style.gridRow = `${r + 1} / span ${SHIP_LENGTH}`; overlay.style.gridColumn = `${c + 1} / span 1`; }
            const svgNS = "http://www.w3.org/2000/svg"; const svg = document.createElementNS(svgNS, "svg"); svg.classList.add("cane-svg");
            const path = document.createElementNS(svgNS, "path");
            path.setAttribute("fill", "none"); path.setAttribute("stroke", "url(#candyStripes)"); path.setAttribute("stroke-width", "35"); path.setAttribute("stroke-linecap", "round"); path.setAttribute("stroke-linejoin", "round");
            let d = "";
            if (isHorizontal) { svg.setAttribute("viewBox", "0 0 400 100"); d = "M380,50 L50,50 A17.5,17.5 0 0,0 50,85"; } 
            else { svg.setAttribute("viewBox", "0 0 100 400"); d = "M50,380 L50,50 A17.5,17.5 0 0,0 15,50"; }
            path.setAttribute("d", d); svg.appendChild(path); overlay.appendChild(svg); container.appendChild(overlay);
        }

        function checkWin() {
            const totalTarget = NUM_SHIPS * SHIP_LENGTH;
            if (hits === totalTarget) { gameActive = false; showEndScreen(true); }
        }

        function checkLoss() {
            if (guessesLeft <= 0 && hits < (NUM_SHIPS * SHIP_LENGTH)) { gameActive = false; showEndScreen(false); }
        }

        function showEndScreen(won) {
            const layer = document.getElementById('ui-layer'); const title = document.getElementById('end-title'); const sub = document.getElementById('end-subtitle'); const btn = document.getElementById('end-btn');
            layer.classList.remove('hidden-ui'); layer.classList.add('active-ui');
            if (won) { title.innerText = "Sweet victory!"; btn.innerText = "Next Puzzle"; btn.onclick = goToNextLevel; } 
            else { title.innerText = "Out of guesses"; btn.innerText = "Try Again"; btn.onclick = initGame; }
        }

        const _nextUrl = [49, 48, 45, 112, 114, 111, 112, 101, 114, 116, 121, 46, 104, 116, 109, 108];
        function goToNextLevel() { window.location.href = String.fromCharCode(..._nextUrl); }
        
        /* --- SNOW ANIMATION (Harmonized) --- */
        const canvas = document.getElementById("snow-canvas");
        const ctx = canvas.getContext("2d");
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        const particles = [];
        const particleCount = 100;

        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.radius = Math.random() * 3 + 1;
                this.speedY = Math.random() * 1 + 0.5;
                this.speedX = Math.random() * 0.5 - 0.25;
                this.opacity = Math.random() * 0.5 + 0.3;
            }
            update() {
                this.y += this.speedY;
                this.x += this.speedX;
                if (this.y > height) this.y = 0;
                if (this.x > width) this.x = 0;
                if (this.x < 0) this.x = width;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.fill();
            }
        }

        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(animate);
        }
        animate();

        initGame();
        
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });
    </script>
</body>
</html>
